# Generated by vibrator
# Do not edit this file directly - modify templates/Dockerfile.template in source

# ============================================================================
# Stage 1: System packages and tools
# ============================================================================
FROM ubuntu:24.04 AS base

RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    wget \
    git \
    python3 \
    python3-pip \
    unzip \
    sudo \
    fzf \
    zsh \
    gh \
    vim \
    htop \
    sqlite3 \
    tree \
    fd-find \
    gpg \
 && rm -rf /var/lib/apt/lists/*

# Install Go from Ubuntu repos (needed by some MCP servers)
RUN apt-get update && \
    apt-get install -y golang-go && \
    rm -rf /var/lib/apt/lists/*

# Install Bun (needed by Playwright MCP server)
ENV BUN_INSTALL=/usr/local
RUN curl -fsSL https://bun.sh/install | bash && \
    ln -sf /usr/local/bin/bun /usr/local/bin/node

# Install Playwright MCP server (npm package only — fast, cached separately)
RUN bun install -g @playwright/mcp

# Install Chromium system dependencies (apt-get only, no browser download — fast & reliable)
# NOTE: playwright-mcp defaults to the "chrome" channel which expects Google Chrome
# at /opt/google/chrome/chrome. We install Chromium (smaller) and create a wrapper
# script at that path. The wrapper injects --no-sandbox flags so Chrome works in
# containers without unprivileged user namespaces (disabled by AppArmor on Ubuntu 23.10+).
ENV PLAYWRIGHT_BROWSERS_PATH=/ms-playwright
RUN bunx playwright install-deps chromium

# Download Chromium browser.
# x86_64: curl is much faster than Playwright's Bun/Node downloader in Docker builds.
#          Version info read from playwright-core's browsers.json for forward compatibility.
# ARM64:  Chrome for Testing has no linux-arm64 builds (https://crbug.com/374811603).
#          Playwright uses a different Chromium source, so we let its own downloader handle it.
RUN set -e && \
    ARCH=$(dpkg --print-architecture) && \
    if [ "$ARCH" = "amd64" ]; then \
      REGISTRY=$(find /usr/local -path '*/playwright-core/browsers.json' | head -1) && \
      test -f "$REGISTRY" || { echo "ERROR: playwright-core browsers.json not found"; exit 1; } && \
      CR_REV=$(node -e "process.stdout.write(require('$REGISTRY').browsers.find(b=>b.name==='chromium').revision)") && \
      CR_VER=$(node -e "process.stdout.write(require('$REGISTRY').browsers.find(b=>b.name==='chromium').browserVersion)") && \
      FF_REV=$(node -e "process.stdout.write(require('$REGISTRY').browsers.find(b=>b.name==='ffmpeg').revision)") && \
      echo "Downloading Chromium ${CR_VER} (rev ${CR_REV}) for linux64 via curl..." && \
      mkdir -p /ms-playwright/chromium-${CR_REV} && \
      curl -fSL --retry 3 --retry-delay 5 \
        "https://cdn.playwright.dev/builds/cft/${CR_VER}/linux64/chrome-linux64.zip" \
        -o /tmp/pw-chrome.zip && \
      unzip -q /tmp/pw-chrome.zip -d /ms-playwright/chromium-${CR_REV}/ && \
      rm /tmp/pw-chrome.zip && \
      echo "  Chrome for Testing: OK" && \
      mkdir -p /ms-playwright/chromium_headless_shell-${CR_REV} && \
      curl -fSL --retry 3 --retry-delay 5 \
        "https://cdn.playwright.dev/builds/cft/${CR_VER}/linux64/chrome-headless-shell-linux64.zip" \
        -o /tmp/pw-headless.zip && \
      unzip -q /tmp/pw-headless.zip -d /ms-playwright/chromium_headless_shell-${CR_REV}/ && \
      rm /tmp/pw-headless.zip && \
      echo "  Chrome Headless Shell: OK" && \
      mkdir -p /ms-playwright/ffmpeg-${FF_REV} && \
      curl -fSL --retry 3 --retry-delay 5 \
        "https://cdn.playwright.dev/dbazure/download/playwright/builds/ffmpeg/${FF_REV}/ffmpeg-linux.zip" \
        -o /tmp/pw-ffmpeg.zip && \
      unzip -q /tmp/pw-ffmpeg.zip -d /ms-playwright/ffmpeg-${FF_REV}/ && \
      rm /tmp/pw-ffmpeg.zip && \
      echo "  FFmpeg: OK"; \
    else \
      echo "ARM64: using Playwright downloader (no Chrome for Testing ARM64 builds)..." && \
      bunx playwright install chromium; \
    fi

# Set up Chrome wrapper — symlink real binary and inject container-safe flags.
# No chmod -R needed: Playwright sets correct permissions during extraction.
RUN mkdir -p /opt/google/chrome && \
    CHROMIUM_BIN=$(find /ms-playwright -name chrome -path '*/chrome-linux*/chrome' | head -1) && \
    test -n "$CHROMIUM_BIN" || { echo "ERROR: Chrome binary not found in /ms-playwright"; find /ms-playwright -type f -name chrome; exit 1; } && \
    ln -sf "$CHROMIUM_BIN" /opt/google/chrome/chrome.real && \
    printf '#!/bin/sh\nexec /opt/google/chrome/chrome.real --no-sandbox --disable-setuid-sandbox --disable-dev-shm-usage "$@"\n' \
      > /opt/google/chrome/chrome && \
    chmod +x /opt/google/chrome/chrome && \
    ln -sf /usr/local/install/global/node_modules/playwright-core/cli.js /usr/local/bin/playwright && \
    chmod +x /usr/local/bin/playwright

# Make Playwright library available for script-based browser automation.
# NODE_PATH lets require('playwright-core') work from any script without hardcoding paths.
ENV NODE_PATH=/usr/local/install/global/node_modules

# Install mcp-hub (kontext-dev/agent-browser) — MCP server aggregation gateway
# Opt-in via --mcp flag; provides Web UI at localhost:8080, SSE at localhost:8087
RUN ARCH=$(dpkg --print-architecture) && \
    if [ "$ARCH" = "amd64" ]; then AGENT_ARCH="amd64"; else AGENT_ARCH="arm64"; fi && \
    curl -fsSL "https://github.com/kontext-dev/agent-browser/releases/download/v1.1.0/agent-browser-v1.1.0-linux-${AGENT_ARCH}.tar.gz" \
    -o agent-browser.tar.gz && \
    tar -xzf agent-browser.tar.gz && \
    mv agent-browser /usr/local/bin/mcp-hub && \
    chmod +x /usr/local/bin/mcp-hub && \
    rm agent-browser.tar.gz

# Install Vercel agent-browser — token-efficient browser automation CLI for AI agents
# Reuses existing Chromium via AGENT_BROWSER_EXECUTABLE_PATH (no duplicate download)
RUN bun install -g agent-browser
ENV AGENT_BROWSER_EXECUTABLE_PATH=/opt/google/chrome/chrome

# Install ralphex (autonomous coding loop for Claude Code)
RUN ARCH=$(dpkg --print-architecture) && \
    RALPHEX_VERSION="0.12.0" && \
    curl -fsSL "https://github.com/umputun/ralphex/releases/download/v${RALPHEX_VERSION}/ralphex_${RALPHEX_VERSION}_linux_${ARCH}.tar.gz" \
    -o ralphex.tar.gz && \
    tar -xzf ralphex.tar.gz && \
    mv ralphex /usr/local/bin/ && \
    chmod +x /usr/local/bin/ralphex && \
    rm ralphex.tar.gz

# Sequential Thinking MCP server (binary registered in Stage 3 as user)
RUN bun install -g @modelcontextprotocol/server-sequential-thinking

# --- Developer CLI tools (latest binary releases) ---

# jq — JSON processor (latest release, faster than apt version)
RUN ARCH=$(dpkg --print-architecture) && \
    curl -fsSL "https://github.com/jqlang/jq/releases/latest/download/jq-linux-${ARCH}" \
    -o /usr/local/bin/jq && chmod +x /usr/local/bin/jq

# ripgrep — Fast regex search (latest release)
# Note: aarch64 has no musl build, use gnu instead
RUN ARCH=$(dpkg --print-architecture) && \
    RG_VERSION="15.1.0" && \
    if [ "$ARCH" = "amd64" ]; then RG_TRIPLE="x86_64-unknown-linux-musl"; else RG_TRIPLE="aarch64-unknown-linux-gnu"; fi && \
    curl -fsSL "https://github.com/BurntSushi/ripgrep/releases/download/${RG_VERSION}/ripgrep-${RG_VERSION}-${RG_TRIPLE}.tar.gz" \
    -o rg.tar.gz && \
    tar -xzf rg.tar.gz --strip-components=1 -C /usr/local/bin/ "ripgrep-${RG_VERSION}-${RG_TRIPLE}/rg" && \
    rm rg.tar.gz

# yq — YAML/JSON/XML processor (like jq but for YAML)
RUN ARCH=$(dpkg --print-architecture) && \
    curl -fsSL "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_${ARCH}" \
    -o /usr/local/bin/yq && chmod +x /usr/local/bin/yq

# hadolint — Dockerfile linter
RUN ARCH=$(dpkg --print-architecture) && \
    if [ "$ARCH" = "amd64" ]; then HL_ARCH="x86_64"; else HL_ARCH="arm64"; fi && \
    curl -fsSL "https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-${HL_ARCH}" \
    -o /usr/local/bin/hadolint && chmod +x /usr/local/bin/hadolint

# delta — Better git diff viewer with syntax highlighting
# Note: aarch64 has no musl build, use gnu instead
RUN ARCH=$(dpkg --print-architecture) && \
    DELTA_VERSION="0.18.2" && \
    if [ "$ARCH" = "amd64" ]; then DELTA_TRIPLE="x86_64-unknown-linux-musl"; else DELTA_TRIPLE="aarch64-unknown-linux-gnu"; fi && \
    curl -fsSL "https://github.com/dandavison/delta/releases/download/${DELTA_VERSION}/delta-${DELTA_VERSION}-${DELTA_TRIPLE}.tar.gz" \
    -o delta.tar.gz && \
    tar -xzf delta.tar.gz --strip-components=1 -C /usr/local/bin/ \
      "delta-${DELTA_VERSION}-${DELTA_TRIPLE}/delta" && \
    rm delta.tar.gz

# websocat — WebSocket CLI client
RUN ARCH=$(dpkg --print-architecture) && \
    if [ "$ARCH" = "amd64" ]; then WS_ARCH="x86_64"; else WS_ARCH="aarch64"; fi && \
    curl -fsSL "https://github.com/vi/websocat/releases/latest/download/websocat.${WS_ARCH}-unknown-linux-musl" \
    -o /usr/local/bin/websocat && chmod +x /usr/local/bin/websocat

# lazygit — Terminal UI for git operations
RUN ARCH=$(dpkg --print-architecture) && \
    if [ "$ARCH" = "amd64" ]; then LG_ARCH="x86_64"; else LG_ARCH="arm64"; fi && \
    LAZYGIT_VERSION="0.44.1" && \
    curl -fsSL "https://github.com/jesseduffield/lazygit/releases/download/v${LAZYGIT_VERSION}/lazygit_${LAZYGIT_VERSION}_Linux_${LG_ARCH}.tar.gz" \
    -o lazygit.tar.gz && \
    tar -xzf lazygit.tar.gz lazygit && \
    mv lazygit /usr/local/bin/ && chmod +x /usr/local/bin/lazygit && \
    rm lazygit.tar.gz

# uv — Python package/tool manager (system-wide so all stages can use it)
RUN curl -LsSf https://astral.sh/uv/install.sh | UV_INSTALL_DIR=/usr/local/bin sh && \
    uv --version

# Create user with host UID/GID for proper file permissions on mounted volumes.
# Ubuntu 24.04 ships with a default 'ubuntu' user at UID 1000 — remove any
# existing user/group that conflicts with the target UID/GID before creating ours.
ARG USERNAME=claude-user
ARG HOST_UID=1000
ARG HOST_GID=1000
RUN EXISTING_USER=$(getent passwd ${HOST_UID} | cut -d: -f1) && \
    [ -n "$EXISTING_USER" ] && userdel -r "$EXISTING_USER" 2>/dev/null || true; \
    EXISTING_GROUP=$(getent group ${HOST_GID} | cut -d: -f1) && \
    [ -n "$EXISTING_GROUP" ] && groupdel "$EXISTING_GROUP" 2>/dev/null || true; \
    groupadd -g ${HOST_GID} ${USERNAME} && \
    useradd -m -s /bin/zsh -u ${HOST_UID} -g ${HOST_GID} ${USERNAME} && \
    echo "${USERNAME} ALL=(root) NOPASSWD:ALL" > /etc/sudoers.d/${USERNAME} && \
    chmod 0440 /etc/sudoers.d/${USERNAME}

# ============================================================================
# Stage 2: User environment (zsh, oh-my-zsh, uv)
# ============================================================================
FROM base AS user-env
ARG USERNAME=claude-user

USER $USERNAME
WORKDIR /home/$USERNAME

RUN sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended && \
    git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions && \
    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

ENV PATH="/home/$USERNAME/.local/bin:$PATH"

# --- Python developer tools (isolated venvs via uv, binaries in ~/.local/bin/) ---
RUN uv tool install ruff && \
    uv tool install httpie && \
    uv tool install csvkit

@@AIDER_SECTION@@

# ============================================================================
# Stage 3: Claude CLI and MCP servers
# ============================================================================
FROM user-env AS claude-mcp
ARG USERNAME=claude-user

RUN curl -fsSL https://claude.ai/install.sh | bash
ENV PATH=/home/$USERNAME/.local/bin:$PATH

RUN claude mcp add context7 \
    --scope user \
    --transport http \
    https://mcp.context7.com/mcp

RUN claude mcp add serena \
    --scope user \
    -- uvx --from git+https://github.com/oraios/serena serena start-mcp-server --project-from-cwd

RUN claude mcp add playwright \
    --scope user \
    --transport stdio \
    -- playwright-mcp --headless --executable-path /opt/google/chrome/chrome

# Sequential Thinking MCP — structured multi-step reasoning (installed in Stage 1)
RUN claude mcp add sequential-thinking \
    --scope user \
    --transport stdio \
    -- mcp-server-sequential-thinking

# SQLite MCP — natural-language database queries
RUN uv tool install mcp-server-sqlite && \
    claude mcp add sqlite \
    --scope user \
    --transport stdio \
    -- mcp-server-sqlite --db-path /tmp/scratch.db

# Install agent-browser skill so Claude auto-discovers it
RUN mkdir -p ~/.claude/skills/agent-browser && \
    cp /usr/local/install/global/node_modules/agent-browser/skills/agent-browser/SKILL.md \
       ~/.claude/skills/agent-browser/SKILL.md

RUN uvx superclaude install

@@PLUGIN_SECTION@@

# ============================================================================
# Stage 4: Final runtime
# ============================================================================
FROM claude-mcp AS runtime
ARG USERNAME=claude-user

USER root

# Install Langfuse SDK for observability hook
RUN pip3 install --break-system-packages langfuse

# Create container-specific Claude rules directory
RUN mkdir -p /opt/container-rules

# Decode and install container rules
RUN echo '@@CONTAINER_RULES_CONTEXT_B64@@' | base64 -d > /opt/container-rules/docker-container-context.md
RUN echo '@@CONTAINER_RULES_SAFETY_B64@@' | base64 -d > /opt/container-rules/safety-restrictions.md

RUN echo '@@ENTRYPOINT_B64@@' | base64 -d > /entrypoint.sh && chmod +x /entrypoint.sh
RUN echo '@@CLAUDE_EXEC_B64@@' | base64 -d > /usr/local/bin/claude-exec && chmod +x /usr/local/bin/claude-exec
RUN echo '@@LANGFUSE_HOOK_B64@@' | base64 -d > /opt/langfuse-hook.py && chmod +x /opt/langfuse-hook.py

USER $USERNAME
WORKDIR /home/$USERNAME

ENV PLAYWRIGHT_BROWSERS_PATH=/ms-playwright
ENV AGENT_BROWSER_EXECUTABLE_PATH=/opt/google/chrome/chrome
ENV COLORTERM=truecolor
ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8

RUN echo '@@ZSHRC_B64@@' | base64 -d > ~/.zshrc

# Seed zsh history so "up arrow" gives a useful first command
RUN echo ': 1731000000:0;claude "/sc:load"' > ~/.zsh_history

ENTRYPOINT ["/entrypoint.sh"]
CMD ["/bin/zsh"]
